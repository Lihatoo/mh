#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob
MIHOMO_ROOT=/home/lht/bfile/mihomo
MIHOMO_BIN=${MIHOMO_ROOT}/mihomo # æŒ‡å‘äºŒè¿›åˆ¶æ–‡ä»¶
PID_FILE=${MIHOMO_ROOT}/run.pid # å›ºå®špidæ–‡ä»¶

API_HOST="127.0.0.1"
API_PORT="9090"
MIXED_PORT="7890" #  é»˜è®¤main
SOCK_PORT="7891"
API_BASE="http://${API_HOST}:${API_PORT}"
API_SECRET="" # è¿™æ˜¯å¯†é’¥ï¼Œç”¨äºéªŒè¯ï¼›å¯¹åº”yamlä¸­è®¾ç½®çš„secretå­—æ®µï¼Œä¿æŒä¸€è‡´å³å¯ï¼›å¦‚æœä¸è®¾ç½®ï¼Œé»˜è®¤ç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸éªŒè¯

# ç®€å•å½©è‰²ï¼ˆä¸å–œæ¬¢é¢œè‰²å°±æŠŠè¿™äº›å˜é‡éƒ½è®¾ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰
c_reset=$'\e[0m'
c_title=$'\e[1;36m'
c_key=$'\e[1;33m'
c_ok=$'\e[1;32m'
c_warn=$'\e[1;31m'
c_dim=$'\e[2m'
urlenc() {
  python3 - <<'PY' "$1"
import sys, urllib.parse
print(urllib.parse.quote(sys.argv[1], safe=''))
PY
}



#===============æµ‹è¯•å°å·¥å…·ï¼Œä¸‹======================================
log() {
    local level=$1
    shift
    echo "[$(date +%H:%M:%S)] [$level] $*"
}
debug() { [[ "${DEBUG:-0}" == "1" ]] && log "DEBUG" "$@"; }
info()  { log "INFO" "$@"; }
warn()  { log "WARN" "$@"; }
error() { log "ERROR" "$@"; }
die()   { error "$@"; exit 1; }
ok()    { log "OK" "$@"; }

need() {
  command -v "$1" >/dev/null 2>&1 || die "missing dependency: $1"
}
test_env() { # æµ‹è¯•ä¸€ä¸‹ç¯å¢ƒ
    need ss
    need yq
    need jq
    need curl
    need find
    [[ -x "$MIHOMO_BIN" ]] || die "mihomo not executable: $MIHOMO_BIN"
    echo "ç¯å¢ƒæ­£ç¡® ; env is ok"
}
test_port() {
  local port
  for port in "$@"; do
    if ss -lnt 2>/dev/null | awk '{print $4}' | grep -qE "(:|\\.)${port}\$"; then
      die "port already in use: $port"
    fi
  done
}
api_get() {
  if [[ -n "${API_SECRET}" ]]; then
    curl -fsS -H "Authorization: Bearer ${API_SECRET}" "${API_BASE}$1"
  else
    curl -fsS "${API_BASE}$1"
  fi
}

api_put() {
  local path="$1"
  local data="$2"
  if [[ -n "${API_SECRET}" ]]; then
    curl -fsS -X PUT -H "Authorization: Bearer ${API_SECRET}" -H 'Content-Type: application/json' \
      -d "$data" "${API_BASE}${path}"
  else
    curl -fsS -X PUT -H 'Content-Type: application/json' -d "$data" "${API_BASE}${path}"
  fi
}

api_delay() {
  local name="$1"
  local timeout="${2:-2000}"
  local url="http://www.gstatic.com/generate_204"
  local enc_name enc_url
  enc_name="$(urlenc "$name")"
  enc_url="$(urlenc "$url")"
  local out
  out="$(api_get "/proxies/${enc_name}/delay?timeout=${timeout}&url=${enc_url}" 2>/dev/null || true)"
  jq -r 'if (.delay|type)=="number" then (.delay|tostring) else "-" end' <<<"$out" 2>/dev/null || echo "-"
}
switch_group_node() {
  # ç”¨æ³•ï¼šswitch_group_node "<group>" "<node>"
  local group="$1"
  local node="$2"
  [[ -n "$group" && -n "$node" ]] || return 1

  local enc_group
  enc_group="$(urlenc "$group")"

  api_put "/proxies/${enc_group}" "$(jq -nc --arg name "$node" '{name:$name}')" >/dev/null
  info "Switched group [$group] -> [$node]"
}
#===============æµ‹è¯•å°å·¥å…·ï¼Œä¸Š======================================


#==============================é…ç½®æ–‡ä»¶è¯»å–ï¼Œä¸‹======================================
get_main_group() {
  local pjson
  pjson="$(api_get "/proxies" 2>/dev/null)" || return 1

  # 1) prefer group named "Proxy"
  if jq -e '.proxies["Proxy"]? != null and .proxies["Proxy"].all? != null' >/dev/null <<<"$pjson"; then
    echo "Proxy"
    return 0
  fi

  # 2) fallback to your heuristic
  jq -r '
    .proxies
    | to_entries
    | map(select(.value.all? != null))
    | (map(select(.value.type?=="Selector" or .value.type?=="URLTest" or .value.type?=="Fallback" or .value.type?=="LoadBalance")) + .)
    | .[0].key // empty
  ' <<<"$pjson"
}

get_now_node() {
  # è¾“å‡ºâ€œå½“å‰èŠ‚ç‚¹åâ€ï¼›å¤±è´¥è¾“å‡ºç©ºå¹¶è¿”å›é 0
  local group pjson
  group="$(get_main_group)" || return 1
  [[ -n "$group" ]] || return 1

  pjson="$(api_get "/proxies" 2>/dev/null)" || return 1
  jq -r --arg g "$group" '.proxies[$g].now // empty' <<<"$pjson"
}


#==============================é…ç½®æ–‡ä»¶è¯»å–ï¼Œä¸Š======================================

#============================æµ‹é€Ÿã€æµ‹é€Ÿç»“æœå¤„ç†ï¼Œä¸‹=================================

speedtest_node_delay() {
  # ç”¨ mihomo å†…ç½® delay API æµ‹æŸä¸ªèŠ‚ç‚¹ï¼Œè¾“å‡º ms æˆ– "-"
  # ç”¨æ³•ï¼šspeedtest_node_delay "<node_name>" [timeout_ms]
  local node="${1:-}"
  local timeout_ms="${2:-1000}"
  [[ -n "$node" ]] || { echo "-"; return 1; }

  # DIRECT/REJECT æ²¡å¿…è¦æµ‹
  if [[ "$node" == "DIRECT" || "$node" == "REJECT" ]]; then
    echo "-"
    return 0
  fi
  api_delay "$node" "$timeout_ms"
}
speedtest_now() {
  # ç”¨æ³•ï¼šspeedtest_now [timeout_ms]
  local timeout_ms="${1:-1000}"
  local node delay
  node="$(get_now_node || true)"
  if [[ -z "$node" ]]; then
    echo "âš ï¸  æ— æ³•è·å–å½“å‰èŠ‚ç‚¹ï¼ˆmihomo API ä¸é€šæˆ–æ²¡æœ‰å¯ç”¨ groupï¼‰"
    return 1
  fi

  delay="$(speedtest_node_delay "$node" "$timeout_ms")"
  # ç®€å•æ‰“ä¸ªæ ‡
  local badge="ğŸŸ¡"
  if [[ "$delay" =~ ^[0-9]+$ ]]; then
    if (( delay <= 150 )); then badge="ğŸŸ¢"
    elif (( delay <= 400 )); then badge="ğŸŸ¡"
    else badge="ğŸ”´"
    fi
  else
    badge="âšª"
  fi
  echo "ğŸ‘‰ å½“å‰èŠ‚ç‚¹ï¼š${node}"
  echo "${badge} å»¶è¿Ÿï¼š${delay} ms  (timeout=${timeout_ms})"
}
wait_api() {
  local t="${1:-5}"  # seconds
  local i=0
  while (( i < t*10 )); do
    if api_get "/proxies" >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.1
    i=$((i+1))
  done
  return 1
}
#============================æµ‹é€Ÿã€æµ‹é€Ÿç»“æœå¤„ç†ï¼Œä¸Š=================================

#============================mihomoé…ç½®ï¼Œä¸‹==================
write_cfg() { # name url file 
  local name="$1"
  local url="$2"

  cat >  "${MIHOMO_ROOT}/$name/config.yaml" <<YAML # ç›´æ¥ä½¿ç”¨è¿™ä¸ªå³å¯
mixed-port: ${MIXED_PORT}
socks-port: ${SOCK_PORT}

allow-lan: false
bind-address: ${API_HOST}
mode: global
log-level: info

external-controller: ${API_HOST}:${API_PORT}
secret: ""

proxy-providers:
  ${name}:
    type: http
    url: "${url}"
    interval: 3600
    path: "${MIHOMO_ROOT}/$name/providers/$name.yaml"

proxy-groups:
  - name: Proxy
    type: select
    use:
      - ${name}
YAML
}

#=====================mihomoé…ç½®ï¼Œä¸Š====================================
print_mihomo_status() {
  local timeout_ms="${1:-2000}"

  # 1) configsï¼šè¿è¡Œæ€ç«¯å£/LAN/mode
  local cfg
  if ! cfg="$(api_get "/configs")"; then
    echo "${c_warn}âœ— Cannot reach mihomo API at ${API_BASE}${c_reset}"
    return 1
  fi

  local allow_lan bind_addr mode log_level mixed_port ec
  allow_lan="$(jq -r '."allow-lan" // false' <<<"$cfg")"
  bind_addr="$(jq -r '."bind-address" // "-"' <<<"$cfg")"
  mode="$(jq -r '.mode // "-"' <<<"$cfg")"
  log_level="$(jq -r '."log-level" // "-"' <<<"$cfg")"
  mixed_port="$(jq -r '."mixed-port" // .port // "-"' <<<"$cfg")"
  ec="$(jq -r '."external-controller" // "-"' <<<"$cfg")"

  local lan_badge
  if [[ "$allow_lan" == "true" ]]; then
    lan_badge="${c_ok}ON${c_reset}"
  else
    lan_badge="${c_warn}OFF${c_reset}"
  fi

  # 2) proxiesï¼šæ‰¾ä¸»ç»„ + now + allï¼ˆèŠ‚ç‚¹åˆ—è¡¨ï¼‰
  local pjson
  pjson="$(api_get "/proxies")" || { echo "${c_warn}âœ— Cannot read /proxies${c_reset}"; return 1; }

  # è‡ªåŠ¨é€‰â€œä¸»ç»„â€ï¼šä¼˜å…ˆ Selector/URLTest/Fallback/LoadBalanceï¼Œå…¶æ¬¡ä»»æ„æœ‰ all çš„
  local group
  group="$(jq -r '
    .proxies
    | to_entries
    | map(select(.value.all? != null))
    | (map(select(.value.type?=="Selector" or .value.type?=="URLTest" or .value.type?=="Fallback" or .value.type?=="LoadBalance")) + .)
    | .[0].key // empty
  ' <<<"$pjson")"

  if [[ -z "$group" ]]; then
    echo "${c_warn}âœ— No proxy groups found in /proxies (unexpected)${c_reset}"
    return 1
  fi

  local now node_count
  now="$(jq -r --arg g "$group" '.proxies[$g].now // "-"' <<<"$pjson")"
  node_count="$(jq -r --arg g "$group" '.proxies[$g].all | length' <<<"$pjson" 2>/dev/null || echo "-")"

  # 3) å½“å‰èŠ‚ç‚¹ delayï¼ˆDIRECT/REJECT ä¸æµ‹ï¼‰
  local now_delay="-"
  if [[ "$now" != "-" && "$now" != "DIRECT" && "$now" != "REJECT" ]]; then
    now_delay="$(api_delay "$now" "$timeout_ms")"
  fi

  # 4) å¥½çœ‹è¾“å‡º
  echo
  echo "${c_title}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Mihomo Live Status â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${c_reset}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "API" "${API_BASE}  ${c_dim}(external-controller=${ec})${c_reset}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "Ports" "mixed-port=${mixed_port}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "LAN" "allow-lan=${lan_badge}  bind=${bind_addr}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "Mode / Log" "mode=${mode}  log-level=${log_level}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "Main Group" "${group}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "Nodes" "count=${node_count}"
  printf "${c_key}â•‘%-16s${c_reset} %-58s â•‘\n" "Now Using" "${now}  ${c_dim}(delay=${now_delay}ms)${c_reset}"
  echo "${c_title}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${c_reset}"
  echo
}

on_off() { # å¯åŠ¨/åœæ­¢ä»£ç†ï¼Œ
    if [[ "$1" == "on" ]]; then
        export HTTP_PROXY="http://${API_HOST}:${MIXED_PORT}"
        export HTTPS_PROXY="http://${API_HOST}:${MIXED_PORT}"
        info "Proxy ON: HTTP_PROXY and HTTPS_PROXY set to ${API_HOST}:${MIXED_PORT}"
        speedtest_now 1000
    elif [[ "$1" == "off" ]]; then
        unset HTTP_PROXY HTTPS_PROXY
        info "Proxy OFF: HTTP_PROXY and HTTPS_PROXY unset"
    else
        die "usage: $0 on|off"
    fi
}
start_end(){  # start/end name/none æ–‡ä»¶
    local start0Rend=$1
    local name_file=${2:-}
    local cfg=$MIHOMO_ROOT/$name_file
    if [[ "$start0Rend" == "start" ]]; then
        start_end "end" # å…ˆåœæ­¢å½“å‰
        if [[ -d $cfg ]];then
            # è¿›å…¥çš„å‰æé…ç½®æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œ
            info "start mihomo with config=$cfg/config.yaml data=$cfg"
            # å‰å°è·‘ä¸æ–¹ä¾¿ï¼Œè¿™é‡Œåå°å¯åŠ¨å¹¶è®°å½• pid
            test_port "$API_PORT" "$MIXED_PORT"
            "$MIHOMO_BIN" -d "$cfg" >"$cfg/mihomo.log" 2>&1 & # æ¯æ¬¡å¯åŠ¨æƒ…å†µè®°å½•
            # on_off on
            echo $! >"$PID_FILE" # ä¿å­˜åˆ°å®šç‚¹ä½ç½®
        fi
    elif [[ "$start0Rend" == "end" ]]; then
        if [[ -f "$PID_FILE" ]]; then # å­˜åœ¨å°±ç»ˆæ­¢
            local pid
            pid="$(cat "$PID_FILE" || true)"
            if [[ -n "${pid}" ]] && kill "$pid" 2>/dev/null; then
              info "stop process  pid=$pid"
              kill "$pid" 2>/dev/null || true
              # ç­‰ä¸€ä¸‹è®©å®ƒé€€å‡º
              for _ in {1..20}; do
                  kill -0 "$pid" 2>/dev/null || break
                  sleep 0.1
              done
              if kill -0 "$pid" 2>/dev/null; then
                warn "force kill pid=$pid"
                kill -9 "$pid" 2>/dev/null || true
              fi
            fi
            rm -f "$PID_FILE"
            # on_off off
        fi
    else
        die "usage: $0 start|end"
    fi
}

cfg_add() { # add name src
  if [[ "$1" == "add" ]]; then
    shift # å»æ‰ "add" å‚æ•°
  fi
  local name="$1"
  local src="$2"
  local cfg_root="${MIHOMO_ROOT}/${name}"
  [[ -n "$name" ]] || die "usage: $0 add <name> <url|file>"
  [[ -n "$src" ]]  || die "usage: $0 add <name> <url|file>"
  if [[ -d "$cfg_root" ]]; then
    die "profile exists: $cfg_root ,è¯·æ¢ä¸€ä¸ªåç§°"
  fi
  mkdir -p "$cfg_root"
  mkdir -p "$cfg_root/providers"  # 
  write_cfg "$name" "$src" 
  if [[ -f "$src" ]]; then #file: ç›´æ¥å¤åˆ¶,ä¸ç”¨ä¸‹è½½äº†
    info "copy file -> ${cfg_root}/providers/$name.yaml"
    cp -f "$src" "$cfg_root/providers/$name.yaml"
    yq -y -i "
      .[\"proxy-providers\"][\"$name\"].type = \"file\" |
      del(.[\"proxy-providers\"][\"$name\"].url) |
      del(.[\"proxy-providers\"][\"$name\"].interval)
    " "$cfg_root/config.yaml"
    info "saved: ${cfg_root}/providers/$name.yaml" # æœ‰äº†æ–‡ä»¶ï¼Œç­‰ä¼šæŒ‚è½½
  fi
    # å¯åŠ¨è¿™ä¸ªé…ç½®
    select_one "select" "$name" # å¯åŠ¨è¿™ä¸ªæ–°çš„èŠ‚ç‚¹
    print_mihomo_status 1000
}

get_group_nodes_json() {
  local pjson group nodes
  pjson="$(api_get "/proxies")" || return 1

  group="$(get_main_group)" || return 1
  [[ -n "$group" ]] || return 1

  nodes="$(jq -c --arg g "$group" '.proxies[$g].all' <<<"$pjson")" || return 1
  jq -nc --arg group "$group" --argjson nodes "$nodes" '{group:$group, nodes:$nodes}'
}

pick_and_switch_by_keyword() {
  # ç”¨æ³•ï¼šmh <keyword>
  local kw="${1:-}"
  [[ -n "$kw" ]] || { warn "usage: mh <keyword>"; return 1; }

  wait_api 5 || { warn "mihomo API not ready"; return 1; }

  local gj group
  gj="$(get_group_nodes_json)" || { warn "cannot read proxies/groups"; return 1; }
  group="$(jq -r '.group' <<<"$gj")"

  # çº¯å­ä¸²åŒ¹é…ï¼šä¸­æ–‡ç›´æ¥ containsï¼›è‹±æ–‡åš lower-case contains
  local candidates
  candidates="$(jq -r --arg kw "$kw" '
    def lc: ascii_downcase;

    .nodes
    | map(select(. != "DIRECT" and . != "REJECT"))
    | map(select(
        (contains($kw))                       # ä¸­æ–‡/åŸæ ·å­ä¸²
        or ((lc) | contains($kw | lc))        # è‹±æ–‡å¿½ç•¥å¤§å°å†™
      ))
    | .[]
  ' <<<"$gj")"

  if [[ -z "$candidates" ]]; then
    warn "No nodes matched keyword: $kw"
    info "Tip: try: ç¾å›½ / é¦™æ¸¯ / æ—¥æœ¬ / ç‹®åŸ / éŸ©å›½ / å°æ¹¾ / US / HK / JP / SG"
    return 1
  fi

  mapfile -t arr <<<"$candidates"

  echo "ğŸ” Matched nodes in group [$group] for keyword: [$kw]"
  local i
  for i in "${!arr[@]}"; do
    printf "  %d) %s\n" "$((i+1))" "${arr[$i]}"
  done

  local pick
  while true; do
    read -r -p "ğŸ‘‰ choose (1-${#arr[@]}, 0 cancel): " pick
    [[ "$pick" =~ ^[0-9]+$ ]] || { echo "âŒ è¯·è¾“å…¥æ•°å­—"; continue; }
    (( pick==0 )) && { echo "cancelled"; return 0; }
    (( pick>=1 && pick<=${#arr[@]} )) || { echo "âŒ è¶…å‡ºèŒƒå›´"; continue; }
    break
  done

  switch_group_node "$group" "${arr[$((pick-1))]}"
  speedtest_now 1200 || true
}


help() {
  cat <<EOF
Usage:
  $0 add <name> <url|file>     # æ–°å»ºä¸€ä¸ª profile ç›®å½•ï¼š${MIHOMO_ROOT}/<name>/
                              # ç”Ÿæˆ config.yamlï¼Œå¹¶æŠŠè®¢é˜…ä½œä¸º proxy-provider
                              # <url>ï¼šåœ¨çº¿è®¢é˜…ï¼ˆtype=httpï¼‰
                              # <file>ï¼šæœ¬åœ°æ–‡ä»¶ï¼ˆtype=fileï¼Œä¼šè‡ªåŠ¨åˆ  url/intervalï¼‰

  $0 select [name]             # åˆ‡æ¢/å¯åŠ¨æŸä¸ª profile
                              # ä¸å¸¦ nameï¼šåˆ—å‡ºç›®å½•ï¼Œè¾“å…¥åºå·é€‰æ‹©
                              # å¸¦ nameï¼šç›´æ¥å¯åŠ¨ ${MIHOMO_ROOT}/<name>/

  $0 start <name>              # ç›´æ¥å¯åŠ¨æŒ‡å®š profileï¼ˆç­‰ä»·äº select nameï¼‰
  $0 end                       # åœæ­¢å½“å‰ mihomoï¼ˆç”¨ ${PID_FILE}ï¼‰

  $0 on                        # å¯¼å‡º HTTP_PROXY/HTTPS_PROXY æŒ‡å‘ 127.0.0.1:${MIXED_PORT}
  $0 off                       # å–æ¶ˆä»£ç†ç¯å¢ƒå˜é‡

  $0                           # æ˜¾ç¤ºç«¯å£ç›‘å¬æƒ…å†µ + å½“å‰èŠ‚ç‚¹æµ‹é€Ÿï¼ˆéœ€è¦ API å°±ç»ªï¼‰
  $0 tnu [on|off|toggle]       Toggle TUN (writes tun: into current profile and restarts)
  $0 -l | --list              # åˆ—å‡ºä¸»ç»„(ä¼˜å…ˆ Proxy)çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶æ ‡è®°å½“å‰èŠ‚ç‚¹
  $0 ç¾å›½                     # æ¨¡ç³Šæœç´¢èŠ‚ç‚¹å¹¶åˆ‡æ¢

Tips:
  - å¦‚æœåˆšå¯åŠ¨å°±æŸ¥èŠ‚ç‚¹å¤±è´¥ï¼ŒåŠ äº† wait_api ä¼šæ›´ç¨³ï¼ˆé¿å… raceï¼‰
  - å½“å‰èŠ‚ç‚¹æ˜¾ç¤º DIRECT ä»£è¡¨è¿˜æ²¡åˆ‡åˆ° provider èŠ‚ç‚¹ï¼Œæˆ– provider æ²¡æ‹‰åˆ°èŠ‚ç‚¹
EOF
}


select_one(){ # select name
  shift 
  local name
  if [[ -z "${1:-}" ]];then
    local -a files
    mapfile -t files < <(find "$MIHOMO_ROOT" -mindepth 1 -maxdepth 1 -type d  -exec test -f '{}/config.yaml' ';' -print | sort)
    if (( ${#files[@]} == 0 )); then
      echo "âš ï¸  ${MIHOMO_ROOT} ä¸‹æ²¡æœ‰æ‰¾åˆ°ä»»ä½• ç›®å½•"
      return 1
    fi
    echo "ğŸ“„ å¯ç”¨é…ç½®ï¼ˆè¾“å…¥åºå·é€‰æ‹©ï¼Œä¾‹å¦‚ 1ï¼‰ï¼š"
    local i
    for i in "${!files[@]}"; do
      printf "  %d) %s\n" "$((i+1))" "$(basename "${files[$i]}")"
    done

    local pick 
    while true; do
      read -r -p "ğŸ‘‰ è¯·è¾“å…¥åºå· (1-${#files[@]}): " pick
      [[ "$pick" =~ ^[0-9]+$ ]] || { echo "âŒ è¯·è¾“å…¥æ•°å­—"; continue; }
      (( pick>=1 && pick<=${#files[@]} )) || { echo "âŒ è¶…å‡ºèŒƒå›´"; continue; }

      name="$(basename "${files[$((pick-1))]}")"
      break
    done
  else
   local file_cfg="$MIHOMO_ROOT/$1"
   if [[ -d $file_cfg ]];then
    name="$1"
   else
    echo "âŒ ä¸å­˜åœ¨: $file_cfg"# è¾“å…¥nameæœ‰æ— 
    return 1
   fi
  fi
    echo "$name" > "${MIHOMO_ROOT}/current.profile"
    start_end "start" "$name"
    wait_api 5 || warn "mihomo API not ready yet"
    speedtest_now 1000

}

#====================tnuæ§åˆ¶ï¼Œä¸‹=========================

current_profile() {
  [[ -f "${MIHOMO_ROOT}/current.profile" ]] || return 1
  cat "${MIHOMO_ROOT}/current.profile"
}

tnu() {
  # ç”¨æ³•ï¼šmh tnu on|off|toggle
  local action="${1:-toggle}"
  local prof
  prof="$(current_profile)" || { warn "no current profile"; return 1; }

  local cfg="${MIHOMO_ROOT}/${prof}/config.yaml"
  [[ -f "$cfg" ]] || { warn "missing config: $cfg"; return 1; }

  local cur
  cur="$(yq -r '.tun.enable // false' "$cfg" 2>/dev/null || echo false)"

  local next
  case "$action" in
    on) next=true ;;
    off) next=false ;;
    toggle) [[ "$cur" == "true" ]] && next=false || next=true ;;
    *) warn "usage: mh tnu on|off|toggle"; return 1 ;;
  esac

  yq -y -i "
    .tun.enable = ${next} |
    .tun.stack = (.tun.stack // \"system\") |
    .tun.device = (.tun.device // \"mihomo\") |
    .tun[\"auto-route\"] = (.tun[\"auto-route\"] // true) |
    .tun[\"auto-detect-interface\"] = (.tun[\"auto-detect-interface\"] // true) |
    .tun[\"dns-hijack\"] = (.tun[\"dns-hijack\"] // []) |
    ( .tun[\"dns-hijack\"] |= ( . + [\"any:53\"] | unique ) ) |

    .dns.enable = ${next} |
    .dns.listen = (.dns.listen // \"127.0.0.1:1053\") |
    .dns[\"enhanced-mode\"] = (.dns[\"enhanced-mode\"] // \"fake-ip\") |
    .dns.nameserver = (.dns.nameserver // [\"223.5.5.5\",\"119.29.29.29\"]) |
    .dns.fallback = (.dns.fallback // [\"1.1.1.1\",\"8.8.8.8\"])
  " "$cfg"



  info "TUN set to ${next} (profile=${prof}), restarting..."
  start_end end
  start_end start "$prof"
  wait_api 5 || warn "mihomo API not ready"
  print_mihomo_status 1200 || true
}

#=============================tnuæ§åˆ¶ï¼Œä¸Š===================

list_nodes() {
  # ç”¨æ³•ï¼šmh -l
  wait_api 5 || { warn "mihomo API not ready"; return 1; }

  local pjson group now
  pjson="$(api_get "/proxies")" || { warn "cannot read /proxies"; return 1; }

  group="$(get_main_group)" || { warn "cannot detect main group"; return 1; }
  now="$(jq -r --arg g "$group" '.proxies[$g].now // ""' <<<"$pjson")"

  echo "ğŸ“Œ Group: ${group}"
  [[ -n "$now" ]] && echo "â­ Now:   ${now}"
  echo

  # åˆ—å‡º all èŠ‚ç‚¹ï¼Œæ’é™¤ DIRECT/REJECT çš„è¯å¯ä»¥åŠ è¿‡æ»¤ï¼›è¿™é‡Œé»˜è®¤å…¨åˆ—å‡ºå¹¶æ ‡è®°å½“å‰
  jq -r --arg g "$group" --arg now "$now" '
    .proxies[$g].all
    | to_entries[]
    | "\(.key + 1)) " + (if .value == $now then "â­ " else "   " end) + .value
  ' <<<"$pjson"
}



#===============================æœç´¢æµ‹é€Ÿæ’åºï¼Œä¸‹======================
# æ‰¹é‡æµ‹å»¶è¿Ÿï¼ˆé»˜è®¤å¹¶å‘ 6ï¼‰ï¼Œè¾“å‡ºï¼š"<delay>\t<node>"
batch_delay() {
  # ç”¨æ³•ï¼šbatch_delay <timeout_ms> <max_jobs> <node1> <node2> ...
  local timeout_ms="${1:-1200}"; shift || true
  local max_jobs="${1:-6}"; shift || true
  local -a nodes=( "$@" )

  # å…¼å®¹ï¼šæ²¡æœ‰èŠ‚ç‚¹ç›´æ¥è¿”å›
  (( ${#nodes[@]} == 0 )) && return 0

  # å¹¶å‘æµ‹
  local tmp
  tmp="$(mktemp)"
  rm -f "$tmp"; : >"$tmp"

  # ç®€å•å¹¶å‘æ§åˆ¶ï¼šåå°è·‘ï¼Œè¶…è¿‡ max_jobs å°± wait ä¸€ä¸ª
  local running=0
  for n in "${nodes[@]}"; do
    (
      local d
      d="$(api_delay "$n" "$timeout_ms")"
      # ç»Ÿä¸€æˆæ•°å€¼ï¼š"-" å˜æˆ 999999ï¼Œä¾¿äºæ’åº
      if [[ "$d" =~ ^[0-9]+$ ]]; then
        printf "%s\t%s\n" "$d" "$n"
      else
        printf "999999\t%s\n" "$n"
      fi
    ) >>"$tmp" &
    running=$((running+1))
    if (( running >= max_jobs )); then
      wait -n 2>/dev/null || wait
      running=$((running-1))
    fi
  done
  wait

  # æ’åºè¾“å‡º
  sort -n "$tmp"
  rm -f "$tmp"
}

# å…³é”®è¯åŒ¹é… + æµ‹é€Ÿæ’åº + é€‰æ‹©åˆ‡æ¢
pick_switch_with_delay() {
  # ç”¨æ³•ï¼špick_switch_with_delay "<keyword>" [timeout_ms]
  local kw="${1:-}"
  local timeout_ms="${2:-1200}"
  [[ -n "$kw" ]] || { warn "usage: mh <keyword>"; return 1; }

  wait_api 5 || { warn "mihomo API not ready"; return 1; }

  local gj group
  gj="$(get_group_nodes_json)" || { warn "cannot read proxies/groups"; return 1; }
  group="$(jq -r '.group' <<<"$gj")"

  # åŒ¹é…å€™é€‰ï¼šä¸­æ–‡ç”¨ containsï¼›è‹±æ–‡ç”¨ lower-case contains
  local candidates
  candidates="$(jq -r --arg kw "$kw" '
    def lc: ascii_downcase;
    .nodes
    | map(select(. != "DIRECT" and . != "REJECT"))
    | map(select(
        (contains($kw)) or ((lc) | contains($kw | lc))
      ))
    | .[]
  ' <<<"$gj")"

  if [[ -z "$candidates" ]]; then
    warn "No nodes matched keyword: $kw"
    info "Tip: try: ç¾å›½ / é¦™æ¸¯ / æ—¥æœ¬ / ç‹®åŸ / éŸ©å›½ / å°æ¹¾ / US / HK / JP / SG"
    return 1
  fi

  mapfile -t arr <<<"$candidates"

  info "Testing delay for ${#arr[@]} nodes (timeout=${timeout_ms}ms)..."
  # å¹¶å‘ 6ï¼šä½ å¯ä»¥æ”¹å¤§/æ”¹å°
  local lines
  lines="$(batch_delay "$timeout_ms" 6 "${arr[@]}")"

  # ç»„è£…æ’åºåçš„èŠ‚ç‚¹æ•°ç»„ï¼ˆæŒ‰ delay ascï¼‰
  local -a sorted_nodes=()
  local -a sorted_delay=()
  while IFS=$'\t' read -r d n; do
    sorted_nodes+=( "$n" )
    sorted_delay+=( "$d" )
  done <<<"$lines"

  echo "ğŸ” Matched nodes in group [$group] for keyword: [$kw]  (sorted by delay)"
  local i showd
  for i in "${!sorted_nodes[@]}"; do
    showd="${sorted_delay[$i]}"
    [[ "$showd" == "999999" ]] && showd="-"   # æ˜¾ç¤ºæ—¶è¿˜åŸ
    printf "  %d) %s\t%s ms\n" "$((i+1))" "${sorted_nodes[$i]}" "$showd"
  done

  local pick
  while true; do
    read -r -p "ğŸ‘‰ choose (1-${#sorted_nodes[@]}, 0 cancel): " pick
    [[ "$pick" =~ ^[0-9]+$ ]] || { echo "âŒ è¯·è¾“å…¥æ•°å­—"; continue; }
    (( pick==0 )) && { echo "cancelled"; return 0; }
    (( pick>=1 && pick<=${#sorted_nodes[@]} )) || { echo "âŒ è¶…å‡ºèŒƒå›´"; continue; }
    break
  done

  switch_group_node "$group" "${sorted_nodes[$((pick-1))]}"
  speedtest_now 1500 || true
}



#==============================æœç´¢æµ‹é€Ÿæ’åºï¼Œä¸Š======================

#============================çŠ¶æ€æ£€æŸ¥ï¼Œä¸‹=====================
detect_tun_ifaces() {
  # è¾“å‡ºæ£€æµ‹åˆ°çš„ TUN/TAP æ¥å£åï¼›æ²¡æœ‰åˆ™ç©º
  local out=""

  # 1) ip linkï¼šåŒ¹é… tun/utun/tapï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
  out="$(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' \
    | grep -iE '(^tun[0-9]*$|^utun[0-9]*$|^tap[0-9]*$|tun|utun|tap|mihomo|clash|meta)' || true)"

  if [[ -n "$out" ]]; then
    echo "$out" | sed '/^$/d' | sort -u
    return 0
  fi

  # 2) ip tuntapï¼šæ›´æƒå¨ï¼ˆæœ‰äº›å‘è¡Œç‰ˆé»˜è®¤ä¸è£… iproute2 çš„ tuntap å­å‘½ä»¤ï¼Œå¤±è´¥å°±å¿½ç•¥ï¼‰
  if ip tuntap show >/dev/null 2>&1; then
    ip tuntap show | awk '{print $1}' | sed '/^$/d' | sort -u
    return 0
  fi

  # 3) /sys/class/netï¼šå…œåº•
  ls /sys/class/net 2>/dev/null | grep -iE '(^tun[0-9]*$|^utun[0-9]*$|^tap[0-9]*$|tun|utun|tap|mihomo|clash|meta)' || true
}

tun_status() {
  local prof cfg enabled
  prof="$(current_profile 2>/dev/null || true)"
  if [[ -z "$prof" ]]; then
    echo "TUN: unknown (no current profile)"
    return 0
  fi

  cfg="${MIHOMO_ROOT}/${prof}/config.yaml"
  if [[ ! -f "$cfg" ]]; then
    echo "TUN: unknown (missing config)"
    return 0
  fi

  enabled="$(yq -r '.tun.enable // false' "$cfg" 2>/dev/null || echo false)"

  # é…ç½®çŠ¶æ€
  if [[ "$enabled" != "true" ]]; then
    echo "TUN: OFF (profile=${prof})"
    return 0
  fi

  # è¿è¡Œæ€ï¼šæ¥å£
  local ifs
  ifs="$(detect_tun_ifaces || true)"
  if [[ -z "$ifs" ]]; then
    echo "TUN: ON in config, but NO tun/tap iface found (profile=${prof})"
  else
    echo "TUN: ON (profile=${prof})"
    echo "TUN ifaces:"
    echo "$ifs" | sed 's/^/  - /'
  fi

  # è¿è¡Œæ€ï¼šé»˜è®¤è·¯ç”±ï¼ˆæ˜¯å¦è¢«æ¥ç®¡ï¼‰
  echo "Default route:"
  ip route show default 2>/dev/null | sed 's/^/  /' || true
}


proxy_env_status() {
  if [[ -n "${HTTP_PROXY:-}" || -n "${HTTPS_PROXY:-}" ]]; then
    echo "Proxy ENV: ON  (HTTP_PROXY=${HTTP_PROXY:-<unset>}  HTTPS_PROXY=${HTTPS_PROXY:-<unset>})"
  else
    echo "Proxy ENV: OFF"
  fi
}

net_test() {
  # éªŒè¯ï¼šç¯å¢ƒå˜é‡ä»£ç†æ˜¯å¦ç”Ÿæ•ˆ + é€šè¿‡ä»£ç†è®¿é—® google
  # 1) èµ°ç³»ç»Ÿç¯å¢ƒï¼ˆå¦‚æœä½  mh on äº†ï¼‰
  echo "== Test via ENV proxy (if enabled) =="
  curl -I -m 10  https://www.cloudflare.com | head -n 1 || echo "âŒ ENV proxy path failed"

  # 2) å¼ºåˆ¶èµ° mihomo mixed-portï¼ˆä¸ä¾èµ–ä½ æ˜¯å¦ exportï¼‰
  echo
  echo "== Test via explicit proxy http://127.0.0.1:${MIXED_PORT} =="
  curl -I -m 10 -x "http://127.0.0.1:${MIXED_PORT}" https://www.cloudflare.com | head -n 1 || echo "âŒ explicit proxy failed"
  echo
  echo "== Current node delay (mihomo API) =="
  speedtest_now 1500 || true
}


#============================çŠ¶æ€æ£€æŸ¥ï¼Œä¸Š=====================
main() {
    if [[ -z "${1:-}"  ]]; then
        ss -lntp | grep -E ':(9090|7890)'|| echo "âŒ æœªæ‰¾åˆ°ä»£ç†æœåŠ¡"
        test_env
        tun_status
        proxy_env_status
        speedtest_now 1000
        # print_mihomo_status
        exit 0
    fi
  case "${1:-}" in
    add) 
        cfg_add "$@";;
    on|off)
        on_off "$@";;
    start|end)
        start_end "$@";;
    select)
        select_one "$@";;
    help|-h|--help) help ;;
    -l|--list|list) list_nodes ;;
    tnu) shift; tnu "${1:-toggle}" ;;
    test) net_test ;;
    # *) pick_and_switch_by_keyword "${1:-}" ;;
    *) pick_switch_with_delay "${1:-}" 1200 ;;
  esac
}

main "$@"
