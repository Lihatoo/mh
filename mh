#!/usr/bin/env bash
set -euo pipefail
shopt -s nullglob
MIHOMO_ROOT=/home/lht/bfile/mihomo
MIHOMO_BIN=${MIHOMO_ROOT}/mihomo # æŒ‡å‘äºŒè¿›åˆ¶æ–‡ä»¶
PID_FILE=${MIHOMO_ROOT}/run.pid # å›ºå®špidæ–‡ä»¶

API_HOST="127.0.0.1"
API_PORT="9090"
MIXED_PORT="7890" #  é»˜è®¤main
SOCK_PORT="7891"
API_BASE="http://${API_HOST}:${API_PORT}"
API_SECRET="" # è¿™æ˜¯å¯†é’¥ï¼Œç”¨äºéªŒè¯ï¼›å¯¹åº”yamlä¸­è®¾ç½®çš„secretå­—æ®µï¼Œä¿æŒä¸€è‡´å³å¯ï¼›å¦‚æœä¸è®¾ç½®ï¼Œé»˜è®¤ç©ºå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸éªŒè¯

# ç®€å•å½©è‰²ï¼ˆä¸å–œæ¬¢é¢œè‰²å°±æŠŠè¿™äº›å˜é‡éƒ½è®¾ä¸ºç©ºå­—ç¬¦ä¸²ï¼‰
urlenc() {
  python3 - <<'PY' "$1"
import sys, urllib.parse
print(urllib.parse.quote(sys.argv[1], safe=''))
PY
}



#===============æµ‹è¯•å°å·¥å…·ï¼Œä¸‹======================================
log() {
    local level=$1
    shift
    echo "[$(date +%H:%M:%S)] [$level] $*"
}
debug() { [[ "${DEBUG:-0}" == "1" ]] && log "DEBUG" "$@"; }
info()  { log "INFO" "$@"; }
warn()  { log "WARN" "$@"; }
error() { log "ERROR" "$@"; }
die()   { error "$@"; exit 1; }
ok()    { log "OK" "$@"; }

need() {
  command -v "$1" >/dev/null 2>&1 || die "missing dependency: $1"
}
test_env() { # æµ‹è¯•ä¸€ä¸‹ç¯å¢ƒ
    need ss
    need yq
    need jq
    need curl
    need find
    [[ -x "$MIHOMO_BIN" ]] || die "mihomo not executable: $MIHOMO_BIN"
    echo "ç¯å¢ƒæ­£ç¡® ; env is ok"
}
test_port() {
  local port
  for port in "$@"; do
    if ss -lnt 2>/dev/null | awk '{print $4}' | grep -qE "(:|\\.)${port}\$"; then
      die "port already in use: $port"
    fi
  done
}
api_get() {
  local path="$1"
  if [[ -n "${API_SECRET}" ]]; then
    curl -fsS --noproxy '*' -H "Authorization: Bearer ${API_SECRET}" "${API_BASE}${path}"
  else
    curl -fsS --noproxy '*' "${API_BASE}${path}"
  fi
}

api_put() {
  local path="$1"
  local data="$2"
  if [[ -n "${API_SECRET}" ]]; then
    curl -fsS --noproxy '*' -X PUT \
      -H "Authorization: Bearer ${API_SECRET}" \
      -H 'Content-Type: application/json' \
      -d "$data" "${API_BASE}${path}"
  else
    curl -fsS --noproxy '*' -X PUT \
      -H 'Content-Type: application/json' \
      -d "$data" "${API_BASE}${path}"
  fi
}


api_delay() {
  local name="$1"
  local timeout="${2:-2000}"
  local url="http://www.gstatic.com/generate_204"
  local enc_name enc_url
  enc_name="$(urlenc "$name")"
  enc_url="$(urlenc "$url")"
  local out
  out="$(api_get "/proxies/${enc_name}/delay?timeout=${timeout}&url=${enc_url}" 2>/dev/null || true)"
  jq -r 'if (.delay|type)=="number" then (.delay|tostring) else "-" end' <<<"$out" 2>/dev/null || echo "-"
}
switch_group_node() {
  # ç”¨æ³•ï¼šswitch_group_node "<group>" "<node>"
  local group="$1"
  local node="$2"
  [[ -n "$group" && -n "$node" ]] || return 1

  local enc_group
  enc_group="$(urlenc "$group")"

  api_put "/proxies/${enc_group}" "$(jq -nc --arg name "$node" '{name:$name}')" >/dev/null
  info "Switched group [$group] -> [$node]"
}

need_root() {
  # ç”¨æ³•ï¼šneed_root "sudo -E $0 tun on"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    warn "æ­¤æ“ä½œéœ€è¦ sudo/root æƒé™"
    warn "è¯·ç”¨ sudo è¿è¡Œï¼š"
    warn "  $1"
    warn "æˆ–ç»™ mihomo äºŒè¿›åˆ¶åŠ èƒ½åŠ›ï¼ˆä¸å¿…æ•´è¿›ç¨‹ rootï¼‰ï¼š"
    warn "  sudo setcap cap_net_admin,cap_net_raw+ep \"$MIHOMO_BIN\""
    return 1
  fi
  return 0
}
#===============æµ‹è¯•å°å·¥å…·ï¼Œä¸Š======================================


#==============================é…ç½®æ–‡ä»¶è¯»å–ï¼Œä¸‹======================================
get_main_group() {
  local pjson
  pjson="$(api_get "/proxies" 2>/dev/null)" || return 1

  # 1) prefer group named "Proxy"
  if jq -e '.proxies["Proxy"]? != null and .proxies["Proxy"].all? != null' >/dev/null <<<"$pjson"; then
    echo "Proxy"
    return 0
  fi

  # 2) fallback to your heuristic
  jq -r '
    .proxies
    | to_entries
    | map(select(.value.all? != null))
    | (map(select(.value.type?=="Selector" or .value.type?=="URLTest" or .value.type?=="Fallback" or .value.type?=="LoadBalance")) + .)
    | .[0].key // empty
  ' <<<"$pjson"
}

get_now_node() {
  # è¾“å‡ºâ€œå½“å‰èŠ‚ç‚¹åâ€ï¼›å¤±è´¥è¾“å‡ºç©ºå¹¶è¿”å›é 0
  local group pjson
  group="$(get_main_group)" || return 1
  [[ -n "$group" ]] || return 1

  pjson="$(api_get "/proxies" 2>/dev/null)" || return 1
  jq -r --arg g "$group" '.proxies[$g].now // empty' <<<"$pjson"
}


#==============================é…ç½®æ–‡ä»¶è¯»å–ï¼Œä¸Š======================================

#============================æµ‹é€Ÿã€æµ‹é€Ÿç»“æœå¤„ç†ï¼Œä¸‹=================================

speedtest_node_delay() {
  # ç”¨ mihomo å†…ç½® delay API æµ‹æŸä¸ªèŠ‚ç‚¹ï¼Œè¾“å‡º ms æˆ– "-"
  # ç”¨æ³•ï¼šspeedtest_node_delay "<node_name>" [timeout_ms]
  local node="${1:-}"
  local timeout_ms="${2:-1000}"
  [[ -n "$node" ]] || { echo "-"; return 1; }

  # DIRECT/REJECT æ²¡å¿…è¦æµ‹
  if [[ "$node" == "DIRECT" || "$node" == "REJECT" ]]; then
    echo "-"
    return 0
  fi
  api_delay "$node" "$timeout_ms"
}
speedtest_now() {
  # ç”¨æ³•ï¼šspeedtest_now [timeout_ms]
  local timeout_ms="${1:-1000}"
  local node delay
  node="$(get_now_node || true)"
  if [[ -z "$node" ]]; then
    echo "âš ï¸  æ— æ³•è·å–å½“å‰èŠ‚ç‚¹ï¼ˆmihomo API ä¸é€šæˆ–æ²¡æœ‰å¯ç”¨ groupï¼‰"
    return 1
  fi

  delay="$(speedtest_node_delay "$node" "$timeout_ms")"
  # ç®€å•æ‰“ä¸ªæ ‡
  local badge="ğŸŸ¡"
  if [[ "$delay" =~ ^[0-9]+$ ]]; then
    if (( delay <= 150 )); then badge="ğŸŸ¢"
    elif (( delay <= 400 )); then badge="ğŸŸ¡"
    else badge="ğŸ”´"
    fi
  else
    badge="âšª"
  fi
  echo "ğŸ‘‰ å½“å‰èŠ‚ç‚¹ï¼š${node}"
  echo "${badge} å»¶è¿Ÿï¼š${delay} ms  (timeout=${timeout_ms})"
}
wait_api() {
  local t="${1:-5}"  # seconds
  local i=0
  while (( i < t*10 )); do
    if api_get "/proxies" >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.1
    i=$((i+1))
  done
  return 1
}
#============================æµ‹é€Ÿã€æµ‹é€Ÿç»“æœå¤„ç†ï¼Œä¸Š=================================

#============================mihomoé…ç½®ï¼Œä¸‹==================
write_cfg() { # name url file 
  local name="$1"
  local url="$2"

  cat >  "${MIHOMO_ROOT}/$name/config.yaml" <<YAML # ç›´æ¥ä½¿ç”¨è¿™ä¸ªå³å¯
mixed-port: ${MIXED_PORT}
socks-port: ${SOCK_PORT}

allow-lan: false
bind-address: ${API_HOST}
mode: global
log-level: info

external-controller: ${API_HOST}:${API_PORT}
secret: ""

proxy-providers:
  ${name}:
    type: http
    url: "${url}"
    interval: 3600
    path: "${MIHOMO_ROOT}/$name/providers/$name.yaml"

proxy-groups:
  - name: Proxy
    type: select
    use:
      - ${name}
YAML
}

#=====================mihomoé…ç½®ï¼Œä¸Š====================================
print_mihomo_status() {
  local cfg pjson
  cfg="$(api_get "/configs" 2>/dev/null)" || { echo "âŒ API ä¸é€š: ${API_BASE}"; return 1; }
  pjson="$(api_get "/proxies" 2>/dev/null)" || { echo "âŒ è¯»å– /proxies å¤±è´¥"; return 1; }

  local allow_lan bind_addr mode mixed_port ec
  allow_lan="$(jq -r '."allow-lan" // false' <<<"$cfg")"
  bind_addr="$(jq -r '."bind-address" // "-"' <<<"$cfg")"
  mode="$(jq -r '.mode // "-"' <<<"$cfg")"
  mixed_port="$(jq -r '."mixed-port" // .port // "-"' <<<"$cfg")"
  ec="$(jq -r '."external-controller" // "-"' <<<"$cfg")"

  local group now node_count
  group="$(get_main_group 2>/dev/null || true)"
  [[ -n "$group" ]] || { echo "âŒ æ‰¾ä¸åˆ°ä¸»ç»„ï¼ˆ/proxies é‡Œæ²¡æœ‰å¯ç”¨ groupï¼‰"; return 1; }

  now="$(jq -r --arg g "$group" '.proxies[$g].now // "-"' <<<"$pjson")"
  node_count="$(jq -r --arg g "$group" '.proxies[$g].all | length' <<<"$pjson" 2>/dev/null || echo "-")"

  local lan_icon="ğŸ”’"
  [[ "$allow_lan" == "true" ]] && lan_icon="ğŸ“¡"

  echo "ğŸ§  Mihomo Status"
  echo "ğŸŒ API:   ${API_BASE}  (EC=${ec})"
  echo "ğŸšª Port:  mixed-port=${mixed_port}"
  echo "${lan_icon} LAN:   allow-lan=${allow_lan}  bind=${bind_addr}"
  echo "ğŸ§­ Mode:  ${mode}"
  echo "ğŸ§© Group: ${group}"
  echo "ğŸ“¦ Nodes: ${node_count}"
  echo "âœ… Now:   ${now}"
}



start_end(){  # start/end name/none æ–‡ä»¶
    local start0Rend=$1
    local name_file=${2:-}
    local cfg=$MIHOMO_ROOT/$name_file
    if [[ "$start0Rend" == "start" ]]; then
        start_end "end" # å…ˆåœæ­¢å½“å‰
        if [[ -d $cfg ]];then
            # è¿›å…¥çš„å‰æé…ç½®æ²¡æœ‰é—®é¢˜ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œ
            info "start mihomo with config=$cfg/config.yaml data=$cfg"
            # å‰å°è·‘ä¸æ–¹ä¾¿ï¼Œè¿™é‡Œåå°å¯åŠ¨å¹¶è®°å½• pid
            test_port "$API_PORT" "$MIXED_PORT" "$SOCK_PORT"
            "$MIHOMO_BIN" -d "$cfg" -f "$cfg/config.yaml" >"$cfg/mihomo.log" 2>&1 & # æ¯æ¬¡å¯åŠ¨æƒ…å†µè®°å½•
            echo $! >"$PID_FILE" # ä¿å­˜åˆ°å®šç‚¹ä½ç½®
        fi
    elif [[ "$start0Rend" == "end" ]]; then
        if [[ -f "$PID_FILE" ]]; then # å­˜åœ¨å°±ç»ˆæ­¢
            local pid
            pid="$(cat "$PID_FILE" || true)"
            if [[ -n "${pid}" ]] && kill "$pid" 2>/dev/null; then
              info "stop process  pid=$pid"
              kill "$pid" 2>/dev/null || true
              # ç­‰ä¸€ä¸‹è®©å®ƒé€€å‡º
              for _ in {1..20}; do
                  kill -0 "$pid" 2>/dev/null || break
                  sleep 0.1
              done
              if kill -0 "$pid" 2>/dev/null; then
                warn "force kill pid=$pid"
                kill -9 "$pid" 2>/dev/null || true
              fi
            fi
            rm -f "$PID_FILE"
        fi
    else
        die "usage: $0 start|end"
    fi
}

cfg_add() { # add name src
  if [[ "$1" == "add" ]]; then
    shift # å»æ‰ "add" å‚æ•°
  fi
  local name="$1"
  local src="$2"
  local cfg_root="${MIHOMO_ROOT}/${name}"
  [[ -n "$name" ]] || die "usage: $0 add <name> <url|file>"
  [[ -n "$src" ]]  || die "usage: $0 add <name> <url|file>"
  if [[ -d "$cfg_root" ]]; then
    die "profile exists: $cfg_root ,è¯·æ¢ä¸€ä¸ªåç§°"
  fi
  mkdir -p "$cfg_root"
  mkdir -p "$cfg_root/providers"  # 
  write_cfg "$name" "$src" 
  if [[ -f "$src" ]]; then #file: ç›´æ¥å¤åˆ¶,ä¸ç”¨ä¸‹è½½äº†
    info "copy file -> ${cfg_root}/providers/$name.yaml"
    cp -f "$src" "$cfg_root/providers/$name.yaml"
    yq -y -i "
      .[\"proxy-providers\"][\"$name\"].type = \"file\" |
      del(.[\"proxy-providers\"][\"$name\"].url) |
      del(.[\"proxy-providers\"][\"$name\"].interval)
    " "$cfg_root/config.yaml"
    info "saved: ${cfg_root}/providers/$name.yaml" # æœ‰äº†æ–‡ä»¶ï¼Œç­‰ä¼šæŒ‚è½½
  fi
    # å¯åŠ¨è¿™ä¸ªé…ç½®
    select_one "select" "$name" # å¯åŠ¨è¿™ä¸ªæ–°çš„èŠ‚ç‚¹
    print_mihomo_status 1000
}

get_group_nodes_json() {
  local pjson group nodes
  pjson="$(api_get "/proxies")" || return 1

  group="$(get_main_group)" || return 1
  [[ -n "$group" ]] || return 1

  nodes="$(jq -c --arg g "$group" '.proxies[$g].all' <<<"$pjson")" || return 1
  jq -nc --arg group "$group" --argjson nodes "$nodes" '{group:$group, nodes:$nodes}'
}


help() {
  cat <<EOF
âœ… å¤åˆ¶ç²˜è´´åˆ°ä½ çš„ shell å¯åŠ¨æ–‡ä»¶ï¼ˆè§ä¸‹æ–¹â€œè¯¥æ”¹å“ªä¸ªæ–‡ä»¶â€ï¼‰ï¼š

# ====== MIHOMO PROXY ENV BEGIN ======
export http_proxy="http://127.0.0.1:${MIXED_PORT}"
export https_proxy="http://127.0.0.1:${MIXED_PORT}"
export all_proxy="socks5h://127.0.0.1:${MIXED_PORT}"

export HTTP_PROXY="\$http_proxy"
export HTTPS_PROXY="\$https_proxy"
export ALL_PROXY="\$all_proxy"

# é¿å…æœ¬åœ°/å†…ç½‘/æ§åˆ¶ç«¯å£èµ°ä»£ç†ï¼ˆæŒ‰éœ€åŠ å‡ï¼‰
export NO_PROXY="127.0.0.1,localhost,::1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
export no_proxy="\$NO_PROXY"
# ====== MIHOMO PROXY ENV END ======

åº”ç”¨æ–¹æ³•ï¼ˆæ”¹å®Œæ–‡ä»¶åæ‰§è¡Œå…¶ä¸€ï¼‰ï¼š
  source ~/.bashrc
  source ~/.zshrc
  exec \$SHELL -l

-------------------------------------------------------------------------------
è¯¥æ”¹å“ªä¸ªæ–‡ä»¶ï¼Ÿï¼ˆå°½é‡å‡†ç¡® + å…œåº•ï¼‰

1) å…ˆçœ‹ä½ å½“å‰æ˜¯ä»€ä¹ˆ shellï¼š
  echo "\$SHELL"
  ps -p \$\$ -o comm=

2) å°è¯•è‡ªåŠ¨åˆ¤æ–­â€œè¿™æ¬¡ä¼šè¯»å“ªä¸ª rc æ–‡ä»¶â€ï¼ˆä¸ä¿è¯ 100% å‡†ç¡®ï¼Œä½†å¾ˆå®ç”¨ï¼‰ï¼š
  # bashï¼šçœ‹çœ‹æ˜¯ä¸æ˜¯ login shell
  shopt -q login_shell && echo "login shell" || echo "non-login shell"

  # zshï¼šçœ‹çœ‹ ZDOTDIR / ä»¥åŠé»˜è®¤è¯» ~/.zshrc
  echo "ZDOTDIR=\${ZDOTDIR:-<unset>}"

3) å¸¸è§è§„åˆ™ï¼ˆæŒ‰ä½ å½“å‰æƒ…å†µé€‰ä¸€ä¸ªæ–‡ä»¶å†™å…¥ï¼‰ï¼š
  - bash + äº¤äº’å¼éç™»å½• shellï¼ˆå¤šæ•°ç»ˆç«¯ tabï¼‰ï¼š~/.bashrc
  - bash + ç™»å½• shellï¼ˆssh ç™»å½• / æœ‰äº›ç»ˆç«¯é…ç½®ï¼‰ï¼š~/.bash_profile æˆ– ~/.profile
  - zshï¼ˆmac å¸¸è§ï¼‰ï¼š~/.zshrc
  - å¦‚æœä½ ä¸ç¡®å®šï¼š
      a) bashï¼šåŒæ—¶å†™ ~/.bashrc å’Œ ~/.bash_profileï¼ˆbash_profile é‡Œæœ€å¥½åŠ ä¸€è¡Œï¼š[[ -f ~/.bashrc ]] && source ~/.bashrcï¼‰
      b) zshï¼šå†™ ~/.zshrc

éªŒè¯æ˜¯å¦ç”Ÿæ•ˆï¼ˆæ–°å¼€ç»ˆç«¯æˆ– source åï¼‰ï¼š
  echo \$http_proxy
  env | grep -iE 'http_proxy|https_proxy|all_proxy|no_proxy'

-------------------------------------------------------------------------------

Usage:
  mh [command] [args...]

Commands:
  add <name> <url|file>
      æ–°å»ºä¸€ä¸ª profile ç›®å½•ï¼š${MIHOMO_ROOT}/<name>/
      - ç”Ÿæˆ config.yaml
      - æŠŠè®¢é˜…ä½œä¸º proxy-provider
      - <url>  åœ¨çº¿è®¢é˜…ï¼ˆtype=httpï¼‰
      - <file> æœ¬åœ°æ–‡ä»¶ï¼ˆtype=fileï¼Œä¼šè‡ªåŠ¨åˆ  url/intervalï¼‰

  select [name]
      åˆ‡æ¢/å¯åŠ¨æŸä¸ª profile
      - ä¸å¸¦ nameï¼šåˆ—å‡ºç›®å½•ï¼Œè¾“å…¥åºå·é€‰æ‹©
      - å¸¦ nameï¼šç›´æ¥å¯åŠ¨ ${MIHOMO_ROOT}/<name>/

  start <name>
      ç›´æ¥å¯åŠ¨æŒ‡å®š profileï¼ˆç­‰ä»·äºï¼šselect <name>ï¼‰

  end
      åœæ­¢å½“å‰ mihomoï¼ˆé€šè¿‡ ${PID_FILE} è®°å½•çš„ pidï¼‰

  tun [on|off|toggle]
      å¼€å…³ TUNï¼ˆä¼šå†™å…¥å½“å‰ profile çš„ config.yaml å¹¶é‡å¯ï¼‰
      - å¼€å¯ TUN é€šå¸¸éœ€è¦ sudo/root æˆ–ç»™ mihomo åŠ èƒ½åŠ›ï¼š
          sudo setcap cap_net_admin,cap_net_raw+ep "<mihomo_bin>"

  -l | --list | list
      åˆ—å‡ºä¸»ç»„(ä¼˜å…ˆ Proxy)çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶æ ‡è®°å½“å‰èŠ‚ç‚¹

  <keyword>
      æ¨¡ç³Šæœç´¢èŠ‚ç‚¹åç§°å¹¶æµ‹é€Ÿæ’åºåè®©ä½ é€‰æ‹©åˆ‡æ¢
      ä¾‹å¦‚ï¼š
        mh ç¾å›½
        mh é¦™æ¸¯
        mh JP
        mh SG

No-args (é»˜è®¤è¡Œä¸º):
  ç›´æ¥æ˜¾ç¤ºï¼š
    - TUN çŠ¶æ€
    - å½“å‰ç¯å¢ƒæ˜¯å¦å­˜åœ¨ HTTP_PROXY/HTTPS_PROXY
    - å½“å‰èŠ‚ç‚¹å»¶è¿Ÿæµ‹é€Ÿï¼ˆé€šè¿‡ mihomo APIï¼‰

-------------------------------------------------------------------------------

Examples:
  # æ·»åŠ è®¢é˜…ï¼ˆåœ¨çº¿ï¼‰
  mh add tnt "https://example.com/sub.yaml"

  # æ·»åŠ è®¢é˜…ï¼ˆæœ¬åœ°æ–‡ä»¶ï¼‰
  mh add local "/path/to/sub.yaml"

  # å¯åŠ¨/åˆ‡æ¢ profile
  mh select
  mh select tnt

  # åœæ­¢ mihomo
  mh end

  # æŸ¥çœ‹èŠ‚ç‚¹åˆ—è¡¨
  mh -l

  # æŒ‰å…³é”®è¯ç­›é€‰å¹¶æµ‹é€Ÿæ’åºååˆ‡æ¢
  mh ç¾å›½

  # TUN å¼€å…³
  sudo mh tun on
  sudo mh tun off
  mh tun toggle

Notes:
  - API ä¸é€šæ—¶ï¼Œå¾ˆå¤šåŠŸèƒ½ä¼šå¤±è´¥ï¼šç¡®ä¿ mihomo æ­£åœ¨è¿è¡Œä¸” external-controller ä¸º ${API_HOST}:${API_PORT}
  - å¦‚æœåˆšå¯åŠ¨å°±æŸ¥è¯¢å¤±è´¥ï¼Œwait_api ä¼šç¨ç­‰ mihomo API å°±ç»ªï¼ˆé¿å… raceï¼‰
EOF
}


select_one(){ # select name
  shift 
  local name
  if [[ -z "${1:-}" ]];then
    local -a files
    mapfile -t files < <(find "$MIHOMO_ROOT" -mindepth 1 -maxdepth 1 -type d  -exec test -f '{}/config.yaml' ';' -print | sort)
    if (( ${#files[@]} == 0 )); then
      echo "âš ï¸  ${MIHOMO_ROOT} ä¸‹æ²¡æœ‰æ‰¾åˆ°ä»»ä½• ç›®å½•"
      return 1
    fi
    echo "ğŸ“„ å¯ç”¨é…ç½®ï¼ˆè¾“å…¥åºå·é€‰æ‹©ï¼Œä¾‹å¦‚ 1ï¼‰ï¼š"
    local i
    for i in "${!files[@]}"; do
      printf "  %d) %s\n" "$((i+1))" "$(basename "${files[$i]}")"
    done

    local pick 
    while true; do
      read -r -p "ğŸ‘‰ è¯·è¾“å…¥åºå· (1-${#files[@]}): " pick
      [[ "$pick" =~ ^[0-9]+$ ]] || { echo "âŒ è¯·è¾“å…¥æ•°å­—"; continue; }
      (( pick>=1 && pick<=${#files[@]} )) || { echo "âŒ è¶…å‡ºèŒƒå›´"; continue; }

      name="$(basename "${files[$((pick-1))]}")"
      break
    done
  else
   local file_cfg="$MIHOMO_ROOT/$1"
   if [[ -d $file_cfg ]];then
    name="$1"
   else
    echo "âŒ ä¸å­˜åœ¨: $file_cfg"# è¾“å…¥nameæœ‰æ— 
    return 1
   fi
  fi
    echo "$name" > "${MIHOMO_ROOT}/current.profile"
    start_end "start" "$name"
    wait_api 5 || warn "mihomo API not ready yet"
    speedtest_now 1000

}

#====================tunæ§åˆ¶ï¼Œä¸‹=========================

current_profile() {
  [[ -f "${MIHOMO_ROOT}/current.profile" ]] || return 1
  cat "${MIHOMO_ROOT}/current.profile"
}

tun() {
  # ç”¨æ³•ï¼šsudo mh tun on|off|toggle
  local action="${1:-toggle}"
  local prof
  prof="$(current_profile)" || { warn "no current profile"; return 1; }

  local cfg="${MIHOMO_ROOT}/${prof}/config.yaml"
  [[ -f "$cfg" ]] || { warn "missing config: $cfg"; return 1; }

  local cur
  cur="$(yq -r '.tun.enable // false' "$cfg" 2>/dev/null || echo false)"

  local next
  case "$action" in
    on) next=true ;;
    off) next=false ;;
    toggle) [[ "$cur" == "true" ]] && next=false || next=true ;;
    *) warn "usage: mh tun on|off|toggle"; return 1 ;;
  esac
  if [[ "$next" == "true" ]]; then  # åªæœ‰â€œè¦å¼€å¯ tunâ€æ‰æç¤º/è¦æ±‚ sudo
    need_root "sudo -E \"$0\" tun ${action}" || return 1
  fi
  yq -y -i "
    .tun.enable = ${next} |
    .tun.stack = (.tun.stack // \"system\") |
    .tun.device = (.tun.device // \"mihomo\") |
    .tun[\"auto-route\"] = (.tun[\"auto-route\"] // true) |
    .tun[\"auto-redir\"] = (.tun[\"auto-redir\"] // true) |
    .tun[\"auto-detect-interface\"] = (.tun[\"auto-detect-interface\"] // true) |
    .tun[\"dns-hijack\"] = (.tun[\"dns-hijack\"] // []) |
    ( .tun[\"dns-hijack\"] |= ( . + [\"any:53\"] | unique ) ) |

    .dns.enable = ${next} |
    .dns.listen = (.dns.listen // \"127.0.0.1:1053\") |
    .dns[\"enhanced-mode\"] = \"redir-host\" |
    .dns.nameserver = (.dns.nameserver // [\"223.5.5.5\",\"119.29.29.29\"]) |
    .dns.fallback = (.dns.fallback // [\"1.1.1.1\",\"8.8.8.8\"])
  " "$cfg"

  info "TUN set to ${next} (profile=${prof}), restarting..."
  start_end end
  start_end start "$prof"
  wait_api 5 || warn "mihomo API not ready"
  print_mihomo_status 1200 || true
}

#=============================tunæ§åˆ¶ï¼Œä¸Š===================

list_nodes() {
  # ç”¨æ³•ï¼šmh -l
  wait_api 5 || { warn "mihomo API not ready"; return 1; }

  local pjson group now
  pjson="$(api_get "/proxies")" || { warn "cannot read /proxies"; return 1; }

  group="$(get_main_group)" || { warn "cannot detect main group"; return 1; }
  now="$(jq -r --arg g "$group" '.proxies[$g].now // ""' <<<"$pjson")"

  echo "ğŸ“Œ Group: ${group}"
  [[ -n "$now" ]] && echo "â­ Now:   ${now}"
  echo

  # åˆ—å‡º all èŠ‚ç‚¹ï¼Œæ’é™¤ DIRECT/REJECT çš„è¯å¯ä»¥åŠ è¿‡æ»¤ï¼›è¿™é‡Œé»˜è®¤å…¨åˆ—å‡ºå¹¶æ ‡è®°å½“å‰
  jq -r --arg g "$group" --arg now "$now" '
    .proxies[$g].all
    | to_entries[]
    | "\(.key + 1)) " + (if .value == $now then "â­ " else "   " end) + .value
  ' <<<"$pjson"
}



#===============================æœç´¢æµ‹é€Ÿæ’åºï¼Œä¸‹======================
# æ‰¹é‡æµ‹å»¶è¿Ÿï¼ˆé»˜è®¤å¹¶å‘ 6ï¼‰ï¼Œè¾“å‡ºï¼š"<delay>\t<node>"
batch_delay() {
  # ç”¨æ³•ï¼šbatch_delay <timeout_ms> <max_jobs> <node1> <node2> ...
  local timeout_ms="${1:-1200}"; shift || true
  local max_jobs="${1:-6}"; shift || true
  local -a nodes=( "$@" )

  # å…¼å®¹ï¼šæ²¡æœ‰èŠ‚ç‚¹ç›´æ¥è¿”å›
  (( ${#nodes[@]} == 0 )) && return 0

  # å¹¶å‘æµ‹
  local tmp
  tmp="$(mktemp)"
  rm -f "$tmp"; : >"$tmp"

  # ç®€å•å¹¶å‘æ§åˆ¶ï¼šåå°è·‘ï¼Œè¶…è¿‡ max_jobs å°± wait ä¸€ä¸ª
  local running=0
  for n in "${nodes[@]}"; do
    (
      local d
      d="$(api_delay "$n" "$timeout_ms")"
      # ç»Ÿä¸€æˆæ•°å€¼ï¼š"-" å˜æˆ 999999ï¼Œä¾¿äºæ’åº
      if [[ "$d" =~ ^[0-9]+$ ]]; then
        printf "%s\t%s\n" "$d" "$n"
      else
        printf "999999\t%s\n" "$n"
      fi
    ) >>"$tmp" &
    running=$((running+1))
    if (( running >= max_jobs )); then
      wait -n 2>/dev/null || wait
      running=$((running-1))
    fi
  done
  wait

  # æ’åºè¾“å‡º
  sort -n "$tmp"
  rm -f "$tmp"
}

# å…³é”®è¯åŒ¹é… + æµ‹é€Ÿæ’åº + é€‰æ‹©åˆ‡æ¢
pick_switch_with_delay() {
  # ç”¨æ³•ï¼špick_switch_with_delay "<keyword>" [timeout_ms]
  local kw="${1:-}"
  local timeout_ms="${2:-1200}"
  [[ -n "$kw" ]] || { warn "usage: mh <keyword>"; return 1; }

  wait_api 5 || { warn "mihomo API not ready"; return 1; }

  local gj group
  gj="$(get_group_nodes_json)" || { warn "cannot read proxies/groups"; return 1; }
  group="$(jq -r '.group' <<<"$gj")"

  # åŒ¹é…å€™é€‰ï¼šä¸­æ–‡ç”¨ containsï¼›è‹±æ–‡ç”¨ lower-case contains
  local candidates
  candidates="$(jq -r --arg kw "$kw" '
    def lc: ascii_downcase;
    .nodes
    | map(select(. != "DIRECT" and . != "REJECT"))
    | map(select(
        (contains($kw)) or ((lc) | contains($kw | lc))
      ))
    | .[]
  ' <<<"$gj")"

  if [[ -z "$candidates" ]]; then
    warn "No nodes matched keyword: $kw"
    info "Tip: try: ç¾å›½ / é¦™æ¸¯ / æ—¥æœ¬ / ç‹®åŸ / éŸ©å›½ / å°æ¹¾ / US / HK / JP / SG"
    return 1
  fi

  mapfile -t arr <<<"$candidates"

  info "Testing delay for ${#arr[@]} nodes (timeout=${timeout_ms}ms)..."
  # å¹¶å‘ 6ï¼šä½ å¯ä»¥æ”¹å¤§/æ”¹å°
  local lines
  lines="$(batch_delay "$timeout_ms" 6 "${arr[@]}")"

  # ç»„è£…æ’åºåçš„èŠ‚ç‚¹æ•°ç»„ï¼ˆæŒ‰ delay ascï¼‰
  local -a sorted_nodes=()
  local -a sorted_delay=()
  while IFS=$'\t' read -r d n; do
    sorted_nodes+=( "$n" )
    sorted_delay+=( "$d" )
  done <<<"$lines"

  echo "ğŸ” Matched nodes in group [$group] for keyword: [$kw]  (sorted by delay)"
  local i showd
  for i in "${!sorted_nodes[@]}"; do
    showd="${sorted_delay[$i]}"
    [[ "$showd" == "999999" ]] && showd="-"   # æ˜¾ç¤ºæ—¶è¿˜åŸ
    printf "  %d) %s\t%s ms\n" "$((i+1))" "${sorted_nodes[$i]}" "$showd"
  done

  local pick
  while true; do
    read -r -p "ğŸ‘‰ choose (1-${#sorted_nodes[@]}, 0 cancel): " pick
    [[ "$pick" =~ ^[0-9]+$ ]] || { echo "âŒ è¯·è¾“å…¥æ•°å­—"; continue; }
    (( pick==0 )) && { echo "cancelled"; return 0; }
    (( pick>=1 && pick<=${#sorted_nodes[@]} )) || { echo "âŒ è¶…å‡ºèŒƒå›´"; continue; }
    break
  done

  switch_group_node "$group" "${sorted_nodes[$((pick-1))]}"
  speedtest_now 1500 || true
}



#==============================æœç´¢æµ‹é€Ÿæ’åºï¼Œä¸Š======================

#============================çŠ¶æ€æ£€æŸ¥ï¼Œä¸‹=====================
tun_status() {
  local prof cfg enabled dev
  prof="$(current_profile 2>/dev/null || true)"
  [[ -n "$prof" ]] || { echo "TUN: unknown (no current profile)"; return 0; }

  cfg="${MIHOMO_ROOT}/${prof}/config.yaml"
  [[ -f "$cfg" ]] || { echo "TUN: unknown (missing config)"; return 0; }

  enabled="$(yq -r '.tun.enable // false' "$cfg" 2>/dev/null || echo false)"
  dev="$(yq -r '.tun.device // "mihomo"' "$cfg" 2>/dev/null || echo mihomo)"

  if [[ "$enabled" != "true" ]]; then
    echo "TUN: OFF (profile=${prof})"
    return 0
  fi

  echo "TUN: ON (profile=${prof})"
  echo "Expect iface: ${dev}"

  if ip link show "$dev" >/dev/null 2>&1; then
    echo "Iface: âœ… ${dev} exists"
  else
    echo "Iface: âŒ ${dev} not found (mihomo tun may not be running/privileged)"
  fi

  echo "Default route:"
  ip route show default 2>/dev/null | sed 's/^/  /' || true
}



proxy_env_status() {
  if [[ -n "${HTTP_PROXY:-}" || -n "${HTTPS_PROXY:-}" ]]; then
    echo "Proxy ENV: ON  (HTTP_PROXY=${HTTP_PROXY:-<unset>}  HTTPS_PROXY=${HTTPS_PROXY:-<unset>})"
  else
    echo "Proxy ENV: OFF"
  fi
}

net_test() {
  # å¸¸ç”¨ç½‘ç«™è¿é€šæ€§æµ‹è¯•ï¼šè¾“å‡º â€œURL -> OK/FAILâ€
  local -a urls=(
    "https://www.google.com"
    "https://www.cloudflare.com"
    "https://www.github.com"
    "https://www.youtube.com"
    "https://www.baidu.com"
    "https://www.bing.com"
  )

  echo "== Net Test (timeout=10s) =="
  local url
  for url in "${urls[@]}"; do
    if curl -fsS -I -m 10 "$url" >/dev/null 2>&1; then
      printf "%s -> âœ… OK\n" "$url"
    else
      printf "%s -> âŒ FAIL\n" "$url"
    fi
  done
}

net_test_double() {
  local -a urls=(
    "https://www.google.com"
    "https://www.cloudflare.com"
    "https://www.github.com"
    "https://www.youtube.com"
    "https://www.baidu.com"
    "https://www.bing.com"
  )

  echo "== Net Test (timeout=10s) =="
  echo "Format: URL -> DIRECT | PROXY(mixed-port=${MIXED_PORT})"
  local url ok1 ok2

  for url in "${urls[@]}"; do
    # ç›´è¿ï¼ˆå®Œå…¨å¿½ç•¥ç¯å¢ƒä»£ç†ï¼‰
    if curl -fsS -I -m 10 --noproxy '*' "$url" >/dev/null 2>&1; then
      ok1="âœ…"
    else
      ok1="âŒ"
    fi

    # å¼ºåˆ¶èµ° mihomo mixed-portï¼ˆæ˜ç¡®æŒ‡å®šä»£ç†ï¼‰
    if curl -fsS -I -m 10 -x "http://127.0.0.1:${MIXED_PORT}" "$url" >/dev/null 2>&1; then
      ok2="âœ…"
    else
      ok2="âŒ"
    fi

    printf "%-28s -> DIRECT:%s  PROXY:%s\n" "$url" "$ok1" "$ok2"
  done
}


#============================çŠ¶æ€æ£€æŸ¥ï¼Œä¸Š=====================

#=========================debug,ä¸‹===============================
debug_one() {
  shift

  local -a debug_code=()
  debug_code[1]="ss -lntp | grep -E ':(9090|9091|7890|7891)'|| echo \"âŒ æœªæ‰¾åˆ°ä»£ç†æœåŠ¡\""
  debug_code[2]="ps -fp \${1:-} -o pid,ppid,cmd"
  debug_code[3]="net_test"
  debug_code[4]="net_test_double"
  debug_code[5]="test_env"
  debug_code[6]="ip -o link show"
  debug_code[7]="resolvectl status 2>/dev/null | sed -n '1,120p' || cat /etc/resolv.conf"

  local -a debug_desc=()
  debug_desc[1]="æ£€æŸ¥ 9090/9091/7890 ç«¯å£ç›‘å¬:"
  debug_desc[2]="æŸ¥çœ‹æŒ‡å®š PID çš„è¿›ç¨‹ä¿¡æ¯:"
  debug_desc[3]="æµ‹è¯•ä¸€ä¸‹ç½‘ç»œ(ä»…proxy)"
  debug_desc[4]="æµ‹è¯•ä¸€ä¸‹ç½‘ç»œ(ç›´è¿+proxy)"
  debug_desc[5]="æµ‹è¯•éœ€è¦çš„è½¯ä»¶æ˜¯å¦å®‰è£…:"
  debug_desc[6]="çœ‹çœ‹æ˜¯å¦æœ‰è™šæ‹Ÿç½‘å¡ mihomo:"
  debug_desc[7]="dns debug"

  echo "== debug list =="
  local i
  for i in "${!debug_code[@]}"; do
    printf "  [%s] %s\n      %s\n" "$i" "${debug_desc[$i]:-}" "${debug_code[$i]}"
  done
  local idx
  read -r -p "select index: " idx

  for i in "${!debug_code[@]}"; do
    if [[ "$i" == "$idx" ]]; then
      echo "== run [$i] =="
      eval "${debug_code[$i]}"
      return $?
    fi
  done

  echo "invalid index: $idx"
  return 1
}

proxy_on() {
  export http_proxy="http://127.0.0.1:${MIXED_PORT}"
  export https_proxy="http://127.0.0.1:${MIXED_PORT}"
  export all_proxy="socks5h://127.0.0.1:${MIXED_PORT}"

  export HTTP_PROXY="$http_proxy"
  export HTTPS_PROXY="$https_proxy"
  export ALL_PROXY="$all_proxy"
# è®¾ç½®noï¼Œæ˜¯ä¸ºäº†é¿å…mihomoè‡ªå·±è®¿é—®è‡ªå·±
  export NO_PROXY="127.0.0.1,localhost,::1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
  export no_proxy="$NO_PROXY"
}

proxy_off() {
  unset http_proxy https_proxy all_proxy HTTP_PROXY HTTPS_PROXY ALL_PROXY NO_PROXY no_proxy
}


# proxy_env() {
#   local action="${1:-}"
#   local bashrc="${HOME}/.bashrc"
#   local port="${2:-${MIXED_PORT:-7890}}"

#   [[ -f "$bashrc" ]] || { echo "âŒ not found: $bashrc"; return 1; }

#   # å¤‡ä»½
#   local bak="${bashrc}.bak.$(date +%Y%m%d%H%M%S)"
#   cp -a "$bashrc" "$bak" || { echo "âŒ backup failed"; return 1; }

#   # 1) å…ˆæ¸…ç†ï¼šæ ‡è®°å— + å¸¸è§ä»£ç† export è¡Œ
#   #    - æ ‡è®°å—ï¼š# >>> MH PROXY BEGIN ... # <<< MH PROXY END
#   #    - ä»¥åŠé›¶æ•£çš„ export http_proxy/HTTP_PROXY/NO_PROXY...ï¼ˆé¿å…æ®‹ç•™ï¼‰
#   perl -0777 -pe '
#     s/\n?# >>> MH PROXY BEGIN\n.*?\n# <<< MH PROXY END\n?/\n/sg;
#   ' -i "$bashrc"

#   # åˆ é™¤é›¶æ•£çš„ä»£ç†è¡Œï¼ˆåªåˆ æˆ‘ä»¬å…³å¿ƒçš„è¿™äº›å˜é‡ï¼‰
#   sed -i \
#     -e '/^[[:space:]]*export[[:space:]]\+\(http_proxy\|https_proxy\|all_proxy\|HTTP_PROXY\|HTTPS_PROXY\|ALL_PROXY\|NO_PROXY\|no_proxy\)=/d' \
#     -e '/^[[:space:]]*\(http_proxy\|https_proxy\|all_proxy\|HTTP_PROXY\|HTTPS_PROXY\|ALL_PROXY\|NO_PROXY\|no_proxy\)=/d' \
#     "$bashrc"

#   case "$action" in
#     on)
#       cat >>"$bashrc" <<EOF

# # >>> MH PROXY BEGIN
# export http_proxy="http://127.0.0.1:${port}"
# export https_proxy="http://127.0.0.1:${port}"
# export all_proxy="socks5h://127.0.0.1:${port}"

# export HTTP_PROXY="\$http_proxy"
# export HTTPS_PROXY="\$https_proxy"
# export ALL_PROXY="\$all_proxy"

# export NO_PROXY="127.0.0.1,localhost,::1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
# export no_proxy="\$NO_PROXY"
# # <<< MH PROXY END
# EOF
#       echo "âœ… proxy_env on: wrote proxy to $bashrc (port=${port})"
#       echo "   apply with: source ~/.bashrc"
#       ;;
#     off)
#       echo "âœ… proxy_env off: removed proxy lines from $bashrc"
#       echo "   apply with: source ~/.bashrc"
#       ;;
#     *)
#       echo "usage:"
#       echo "  proxy_env on [port]   # write proxy exports into ~/.bashrc (default port=\${MIXED_PORT:-7890})"
#       echo "  proxy_env off         # remove proxy exports from ~/.bashrc"
#       echo "backup:"
#       echo "  $bak"
#       return 1
#       ;;
#   esac
# }

#=========================debug,ä¸Š===============================

main() {
    proxy_on
    # unset http_proxy https_proxy all_proxy HTTP_PROXY   # åœæ­¢ä¸€äº›ç”¨æ³•ï¼Œç»ˆæ­¢ä¸€äº›env
    if [[ -z "${1:-}"  ]]; then
        tun_status
        proxy_env_status
        speedtest_now 1000
        # print_mihomo_status
        exit 0
    fi
  case "${1:-}" in
    add)
        cfg_add "$@";;
    start|end)
        start_end "$@";;
    select)
        select_one "$@";;
    db)
        debug_one "$@";;
    help|-h|--help) help ;;
    -l|--list|list) list_nodes ;;
    tun) shift; tun "${1:-toggle}" ;;
    *) pick_switch_with_delay "${1:-}" 1200 ;;
  esac
}
main "$@"
